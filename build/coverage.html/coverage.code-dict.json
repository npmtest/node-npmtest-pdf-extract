{"/home/travis/build/npmtest/node-npmtest-pdf-extract/test.js":"/* istanbul instrument in package npmtest_pdf_extract */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-pdf-extract/lib.npmtest_pdf_extract.js":"/* istanbul instrument in package npmtest_pdf_extract */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_pdf_extract = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_pdf_extract = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-pdf-extract/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-pdf-extract && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_pdf_extract */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_pdf_extract\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_pdf_extract.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_pdf_extract.rollup.js'] =\n            local.assetsDict['/assets.npmtest_pdf_extract.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_pdf_extract.__dirname + '/lib.npmtest_pdf_extract.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-pdf-extract/node_modules/pdf-extract/main.js":"/**\n * @title Node PDF main.js\n * Node PDF allows you to convert pdf files into raw text. The library supports\n * text extraction from electronic searchable pdfs.\n *\n * In addition, the library supports OCR text extract from pdfs which just\n * contain scanned images via the tesseract-ocr engine\n *\n * Multi-page pdfs are supported for both searchable and image pdfs.\n * The library returns an array of strings where the string at a given\n * index in the output array cooresponds the page in the input pdf document\n *\n * @author Noah Isaacson\n * @date 2012-10-26\n */\nvar path = require('path');\nvar temp = require('temp');\nvar exec = require('child_process').exec;\nvar fs = require('fs');\nvar walk = require('walk');\nvar async = require('async');\nvar rimraf = require('rimraf');\n\nvar Raw = require('./lib/raw');\nvar Electronic = require('./lib/electronic');\n\n/**\n * To process a pdf, pass in the absolute path to the pdf file on disk\n\n * @param {Object} params should have the following fields set\n * @param {String} params.pdf_path the absolute path to the pdf file on disk\n * @param {Boolean} params.clean true if you want the temporary single page pdfs\n * @param {Boolean} options.type must be either \"ocr\" or \"text\"\n *\n * @return {Array} text_pages is an array of strings, where each string is the\n * extracted text for the matching page index in the pdf document\n * @return {Processor} a processor object which will emit events as they occur\n */\nmodule.exports = function(pdf_path, options, cb) {\n  var err;\n  var processor = new Raw();\n  if (!'pdf_path') {\n    err = 'you must supply a pdf path as the first parameter'\n    return cb(err);\n  }\n  if (!options) {\n    err =  'no options supplied. You must supply an options object with the \"type\" field set'\n    return cb(err);\n  }\n  if (!options.hasOwnProperty('type') || ! options.type) {\n    err  ='error, you must specify the type of extraction you wish to perform in the options object. Allowed values are \"ocr\" or \"text\"';\n    return cb(err);\n  }\n  if (options.type === 'ocr') {\n    processor = new Raw();\n  }\n  else if (options.type === 'text') {\n    processor = new Electronic();\n  }\n  else {\n    err  ='error, you must specify the type of extraction you wish to perform in the options object. Allowed values are \"ocr\" or \"text\"';\n    return cb(err);;\n  }\n  fs.exists(pdf_path, function (exists) {\n    if (!exists) {\n      err = 'no file exists at the path you specified';\n      return cb(err);\n    }\n    processor.process(pdf_path, options);\n    cb();\n  });\n  return processor;\n}\n","/home/travis/build/npmtest/node-npmtest-pdf-extract/node_modules/pdf-extract/lib/raw.js":"/**\n * Module which extracts the text out of an electronic pdf file\n * This module can handle multi-page pdf files\n\n */\nvar util = require('util');\nvar events = require('events');\nvar fs = require('fs');\nvar async = require('async');\nvar split = require('./split.js');\nvar convert = require('./convert.js');\nvar pathHash = require('pathhash');\nvar ocr = require('./ocr.js');\nvar rimraf = require('rimraf');\n\n\nfunction Raw(){\n  if(false === (this instanceof Raw)) {\n    return new Raw();\n  }\n}\nutil.inherits(Raw, events.EventEmitter);\nmodule.exports = Raw;\n\n\n/**\n * @param {String} pdf_path path to the pdf file on disk\n * @param {Boolean} params.clean true to remove the temporary single-page pdf\n *   files from disk. Sometimes however you might want to be able to use those\n *   single page pdfs after the ocr completes. In this case pass clean = false\n *\n * @return {Array} text_pages an array of the extracted text where\n *   each entry is the text for the page at the given index\n * @return callback(<maybe error>, text_pages)\n */\nRaw.prototype.process = function(pdf_path, options) {\n  var self = this;\n  var text_pages = [];\n  var split_output;\n  if (!options) {\n    options = {};\n  }\n  // default to removing the single page pdfs after ocr completes\n  if (!options.hasOwnProperty('clean')) {\n    options.clean = true;\n  }\n  fs.exists(pdf_path, function (exists) {\n    if (!exists) {\n      var err = 'no file exists at the path you specified: ' + pdf_path\n      self.emit('error', { error: err, pdf_path: pdf_path});\n      return\n    }\n    pathHash(pdf_path, function (err, hash) {\n      if (err) {\n        err = 'error hashing file at the path you specified: ' + pdf_path + '. ' + err;\n        self.emit('error', { error: err, pdf_path: pdf_path});\n        return;\n      }\n      split(pdf_path, function (err, output) {\n        if (err) {\n          self.emit('error', { error: err, pdf_path: pdf_path});\n          return\n        }\n        if (!output) {\n          err = 'no files returned from split';\n          self.emit('error', { error: err, pdf_path: pdf_path});\n          return;\n        }\n        self.emit('log', 'finished splitting pages for file at path ' + pdf_path);\n        split_output = output;\n        var pdf_files = output.files;\n        if (!pdf_files || pdf_files.length == 0) {\n          err = 'error, no pages where found in your pdf document';\n          self.emit('error', { error: err, pdf_path: pdf_path});\n          return;\n        }\n        var index = 0;\n        var num_pages = pdf_files.length\n        var single_page_pdf_file_paths = [];\n        async.forEachSeries(\n          pdf_files,\n          // extract the text for each page via ocr\n          function (pdf_file, cb) {\n            var quality = 300;\n            if (options.hasOwnProperty('quality') && options.quality) {\n              quality = options.quality;\n            }\n            convert(pdf_file.file_path, quality, function (err, tif_path) {\n              var zeroBasedNumPages = num_pages-1;\n              self.emit('log', 'converted page to intermediate tiff file, page '+ index+ ' (0-based indexing) of '+ zeroBasedNumPages);\n              if (err) { return cb(err); }\n              var ocr_flags = [\n                '-psm 6'\n              ];\n              if (options.ocr_flags) {\n                ocr_flags = options.ocr_flags;\n              }\n              ocr(tif_path, ocr_flags, function (err, extract) {\n                fs.unlink(tif_path, function (tif_cleanup_err, reply) {\n                  if (tif_cleanup_err) {\n                    err += ', error removing temporary tif file: \"'+tif_cleanup_err+'\"';\n                  }\n                  if (err) { return cb(err); }\n                  var page_number = index+1\n                  self.emit('log', 'raw ocr: page ' + index + ' (0-based indexing) of ' +zeroBasedNumPages + ' complete');\n                  single_page_pdf_file_paths.push(pdf_file.file_path);\n                  self.emit('page', { hash: hash, text: extract, index: index, num_pages: num_pages, pdf_path: pdf_path, single_page_pdf_path: pdf_file.file_path});\n                  text_pages.push(extract);\n                  index++;\n                  cb();\n                });\n              });\n            });\n          }, function (err) {\n            if (err) {\n              self.emit('error', err);\n              return;\n            }\n            self.emit('complete', { hash: hash, text_pages: text_pages, pdf_path: pdf_path, single_page_pdf_file_paths: single_page_pdf_file_paths});\n          });\n      });\n    });\n  });\n}\n","/home/travis/build/npmtest/node-npmtest-pdf-extract/node_modules/pdf-extract/lib/split.js":"/**\n * Module which splits multi-pag pdfs into single pages\n * Requires the pdftk binary be installed on the system and accessible in the\n * current path\n */\nvar path = require('path');\nvar temp = require('temp');\nvar exec = require('child_process').exec;\nvar fs = require('fs');\nvar walk = require('walk');\nvar async = require('async');\nvar rimraf = require('rimraf');\n\n/**\n * @param pdf_path path to the pdf file on disk\n *\n * @see get_pdfs_in_directory\n * @return {Object} an object with the fields \"folder\" and \"files\" set\n *   files is an array of the absolute paths to the single page pdf files.\n *\n *   Each entry in this array is an object with fields\n *    <file_name> and <file_path> set\n *\n * @return callback(<maybe error>, output_paths)\n */\nmodule.exports = function(pdf_path, callback) {\n  confirm_file_exists(pdf_path, function (err) {\n    if (err) { return callback(err); }\n\n    var output_dir = temp.path({},'pdf_pages');\n    fs.mkdir(output_dir, function(err) {\n      if (err) { return callback(err, null); }\n      // name the files with the upload id and a digit string\n      // example: \"507c3e55c786e2aa6f000005-page00001.pdf\"\n      var output_name = 'page%05d.pdf\"';\n      var output_path = path.join(output_dir, output_name);\n      var cmd = 'pdftk \"'+pdf_path+'\" burst output \"'+ output_path;\n      var child = exec(cmd, function (err, stdout, stderr) {\n        if (err) {\n          var output_err = {\n            message: 'an error occurred while splitting pdf into single pages with the pdftk burst command',\n            error: err\n          }\n          callback(output_err, null);\n          return;\n        }\n        remove_doc_data(function (err, reply) {\n          if (err) { return callback(err); }\n          return get_pdfs_in_directory(output_dir, callback);\n        });\n      });\n    });\n  });\n}\n\n\n\n/**\n * Non-recursive find of all the files in a given directory that end with *.pdf\n * @return {Object} output an object with the fields \"folder\" and \"files\" set\n *   files is an array of the absolute paths to the single page pdf files.\n *\n *   Each entry in this array is an object with fields\n *    <file_name> and <file_path> set\n *\n * @return callback(<maybe error>, output)\n */\nfunction get_pdfs_in_directory(directory_path, callback) {\n  var file_paths = [];\n  var files = null;\n  var walker = walk.walk(directory_path, { followLinks: false});\n  walker.on('file', function(root, stat, next) {\n    if (stat.name.match(/\\.pdf$/i)) {\n      var file_path = path.join(directory_path, stat.name);\n      file_paths.push({file_path: file_path, file_name: stat.name});\n    }\n    next();\n  });\n\n\n  walker.on('end', function() {\n    file_paths.sort(function (a,b) {\n      if (a.file_name < b.file_name) {\n        return -1;\n      }\n      if (a.file_name == b.file_name) {\n        return 0;\n      }\n      return 1;\n    });\n    var output = {\n      folder: directory_path,\n      files: file_paths\n    }\n    return callback(null, output);\n  });\n}\n\n\n/**\n * @param {String} file_path absolute path to file on disk\n * @return {Function} callback() if file does exist\n * callback(<error message>) if file does not exists\n */\nfunction confirm_file_exists(file_path, callback) {\n  fs.exists(file_path, function (exists) {\n    if (!exists) {\n      return callback('no file at path: ' + file_path);\n    }\n    return callback();\n  });\n};\n\n/**\n * pdftk creates a file called doc_data.txt during the burst split process.\n * This file is not needed so remove it now\n */\nfunction remove_doc_data(callback) {\n  var folder = path.join(__dirname, '..');\n  var doc_data_path = path.join(folder, 'doc_data.txt');\n  fs.exists(doc_data_path, function (exists) {\n    if (!exists) {\n      return callback();\n    }\n    fs.unlink(doc_data_path, callback);\n  });\n}\n","/home/travis/build/npmtest/node-npmtest-pdf-extract/node_modules/pdf-extract/lib/convert.js":"/**\n * Converts a pdf file at a given path to a tiff file with\n * the GraphicsMagick command \"convert\"\n */\nvar temp = require('temp');\nvar path = require('path');\nvar exec = require('child_process').exec\nvar spawn = require('child_process').spawn;\nvar fs = require('fs');\nvar pdf_convert_quality = 400; // default to density 400 for the convert command\n\n\n/**\n * @param input_path the path to a pdf file on disk. Since GhostScript requires random file access, we need a path\n *   to an actual file rather than accepting a stream\n * @param {String} quality is an optional flag that controls the quality of the pdf to tiff conversion.\n * @return {String} output_path the path to the converted tif file\n * @return callback(<maybe error>, output_path)\n */\nexports = module.exports = function convert(input_path, quality, callback) {\n  // options is an optional parameter\n  if (!callback || typeof callback != \"function\") {\n    callback = quality;   // callback must be the second parameter\n    quality = undefined;  // no option passed\n  }\n\n  fs.exists(input_path, function (exists) {\n    if (!exists) { return callback('error, no file exists at the path you specified: ' + input_path); }\n    // get a temp output path\n\n    var output_path = temp.path({prefix: 'tif_output', suffix:'.tif'});\n    // var output_path = path.join(__dirname,'test/test_data/single_page_raw.tif');\n    var params = [\n\n      // '-depth 8',\n      // '-background white',\n      // '-flatten +matte',\n      // '-density '+pdf_convert_quality,\n      input_path,\n      output_path\n    ];\n    if (quality) {\n      if (typeof(quality) !== 'string' && typeof(quality) !== 'number') {\n        return callback('error, pdf quality option must be a string, you passed a ' + typeof(quality));\n      }\n      pdf_convert_quality = quality;\n    }\n    var cmd = 'gs -sDEVICE=tiffgray -r720x720 -g6120x7920 -sCompression=lzw -o \"' + output_path + '\" \"'+input_path+'\"';\n    // var cmd = 'convert -depth 8 -background white -flatten +matte -density '+pdf_convert_quality+' \"'+ input_path +'\"  \"' + output_path+'\"';\n    var child = exec(cmd, function (err, stderr, stdout) {\n      if (err) {\n        return callback(err);\n      }\n      return callback(null, output_path);\n    });\n  });\n}\n","/home/travis/build/npmtest/node-npmtest-pdf-extract/node_modules/pdf-extract/lib/ocr.js":"/**\n * Module which extracts text from electronic searchable pdf files.\n * Requires the \"pdftotext\" binary be installed on the system and accessible in the\n * current path\n */\nvar temp = require('temp');\nvar path = require('path');\nvar exec = require('child_process').exec;\nvar fs = require('fs');\n\n/**\n * @param tif_path path to the single page file on disk containing a scanned image of text\n * @param {Array} options is an optional list of flags to pass to the tesseract command\n * @return {String} extract the extracted ocr text output\n * @return callback(<maybe error>, stdout)\n */\nmodule.exports = function(input_path, options, callback) {\n  // options is an optional parameter\n  if (!callback || typeof callback != \"function\") {\n    // callback must be the second parameter\n    callback = options;\n    options = [];\n  }\n  fs.exists(input_path, function (exists) {\n    if (!exists) { return callback('error, no file exists at the path you specified: ' + input_path); }\n    // get a temp output path\n    var output_path = temp.path({prefix: 'ocr_output'});\n    // output_path = path.join(__dirname,'test/test_data/single_page_raw');\n    var cmd = 'tesseract \"'+input_path+'\" \"'+output_path+'\" '+options.join(' ');\n    var child = exec(cmd, function (err, stdout, stderr) {\n      if (err) { return callback(err); }\n      // tesseract automatically appends \".txt\" to the output file name\n      var text_output_path = output_path+'.txt';\n      // inspect(text_output_path, 'text output path');\n      fs.readFile(text_output_path, 'utf8', function(err, output) {\n        // inspect(output, 'ocr output');\n        if (err) { return callback(err); }\n        // cleanup after ourselves\n        fs.unlink(text_output_path, function (err) {\n          if (err) { return callback(err); }\n          callback(null, output);\n        });\n      });\n    });\n  });\n}\n","/home/travis/build/npmtest/node-npmtest-pdf-extract/node_modules/pdf-extract/lib/electronic.js":"/**\n * Module which extracts the text out of an electronic pdf file\n * This module can handle multi-page pdf files\n */\nvar fs = require('fs');\nvar async = require('async');\n\nvar rimraf = require('rimraf');\nvar util = require('util');\nvar events = require('events');\n\nvar split = require('./split.js');\nvar searchable = require('./searchable.js');\nvar pathhash = require('pathhash');\n\n\nfunction Electronic(){\n  if(false === (this instanceof Electronic)) {\n    return new Electronic();\n  }\n}\nutil.inherits(Electronic, events.EventEmitter);\nmodule.exports = Electronic;\n\n\n/**\n * @param pdf_path path to the pdf file on disk\n *\n * @return {Array} text_pages an array of the extracted text where\n *   each entry is the text for the page at the given index\n * @return callback(<maybe error>, text_pages)\n */\nElectronic.prototype.process = function(pdf_path, options) {\n  var self = this;\n  var text_pages = [];\n  var split_output;\n  var single_page_pdf_file_paths = [];\n  fs.exists(pdf_path, function (exists) {\n    var err;\n    if (!exists) {\n      err = 'no file exists at the path you specified: ' + pdf_path\n      self.emit('error', { error: err, pdf_path: pdf_path});\n      return\n    }\n    pathhash(pdf_path, function (err, hash) {\n      if (err) {\n        err = 'error hashing file at the path you specified: ' + pdf_path + '. ' + err;\n        self.emit('error', { error: err, pdf_path: pdf_path});\n        return\n      }\n      // split the pdf into single page pdf files\n      split(pdf_path, function (err, output) {\n        if (err) {\n          self.emit('error', { error: err, pdf_path: pdf_path});\n          return\n        }\n\n\n        if (!output) {\n          err = 'failed to split pdf file into distinct pages';\n          self.emit('error', { error: err, pdf_path: pdf_path});\n          return\n        }\n        split_output = output;\n        if (!split_output.hasOwnProperty('files') || split_output.files.length == 0) {\n          err = 'no pages where found in your pdf document';\n          self.emit('error', { error: err, pdf_path: pdf_path});\n          return\n        }\n        self.emit('log', 'finished splitting pages for file at path ' + pdf_path);\n        var files = split_output.files;\n        var index = 0;\n        async.forEachSeries(\n          files,\n          // extract the text for each page\n          function (file, cb) {\n            index++;\n            searchable(file.file_path, options, function (err, extract) {\n\t          if(err){\n\t            self.emit('error', { error: err, pdf_path: pdf_path});\n\t            return;\n\t          }\n              text_pages.push(extract);\n              var file_path = file.file_path\n              single_page_pdf_file_paths.push(file.file_path);\n              self.emit('page', { hash: hash, text: extract, index: index, pdf_path: pdf_path});\n              cb();\n            });\n          },\n          function (err) {\n            if (!err) {\n              self.emit('complete', { hash: hash, text_pages: text_pages, pdf_path: pdf_path, single_page_pdf_file_paths: single_page_pdf_file_paths});\n              return;\n            }\n            self.emit('error', { error: err, pdf_path: pdf_path});\n            if (!split_output || ! split_output.folder) { return }\n            fs.exists(split_output.folder, function (exists) {\n              if (!exists) { return }\n              var remove_cb = function() {}\n              rimraf(split_output.folder, remove_cb);\n            });\n          }\n        );\n      });\n    });\n  });\n}\n","/home/travis/build/npmtest/node-npmtest-pdf-extract/node_modules/pdf-extract/lib/searchable.js":"/**\n * Module which extracts text from electronic searchable pdf files.\n * Requires the \"pdftotext\" binary be installed on the system and accessible in the\n * current path\n */\nvar path = require('path');\nvar temp = require('temp');\nvar exec = require('child_process').exec;\nvar spawn = require('child_process').spawn;\nvar fs = require('fs');\nvar walk = require('walk');\nvar async = require('async');\nvar rimraf = require('rimraf');\n\n/**\n * @param pdf_path path to the single page searchable pdf file on disk\n * This function buffers all the output from stdout and sends it back as a string.\n * Since we only handle single pages of pdf text here the amount of text is small\n * and therefore we don't need to use a stream\n *\n * @return {ReadStream} the entire output from stdout\n * @return callback(<maybe error>, stdout)\n */\nmodule.exports = function(pdf_path, options, callback) {\n  if(options===undefined)options={};\n  if(options.layout===undefined)options.layout=true;\n  confirm_file_exists(pdf_path, function (err) {\n    if (err) { return callback(err); }\n    var child = spawn('pdftotext', (options.layout ? ['-layout'] : []).concat([pdf_path, '-']));\n    var stdout = child.stdout;\n    var stderr = child.stderr;\n    var output = '';\n    stdout.setEncoding('utf8');\n    stderr.setEncoding('utf8');\n    stderr.on('data', function(data) {\n      return callback(data, null);\n    });\n    // buffer the stdout output\n    stdout.on('data', function(data) {\n      output += data;\n    });\n    stdout.on('close', function(data) {\n      return callback(null, output);\n    });\n  });\n}\n\n\n/**\n * Non-recursive find of all the files in a given directory that end with *.pdf\n * @return {Array} files is an array of the absolute paths to the single\n * page pdf files. Each entry in this array is an object with fields\n * <file_name> and <file_path> set\n * @return callback(<maybe error>, files)\n */\nfunction get_pdfs_in_directory(directory_path, callback) {\n  var file_paths = [];\n  var files = null;\n  var walker = walk.walk(directory_path, { followLinks: false});\n  walker.on('file', function(root, stat, next) {\n    if (stat.name.match(/\\.pdf$/i)) {\n      var file_path = path.join(directory_path, stat.name);\n      file_paths.push({file_path: file_path, file_name: stat.name});\n      next();\n    }\n  });\n  walker.on('end', function() {\n    return callback(null, file_paths);\n  });\n}\n\n/**\n * Cleanup any single page pdfs on error\n */\nfunction cleanup_directory(directory_path, callback) {\n  // only remove the folder at directory_path if it exists\n  fs.exists(directory_path, function (exists) {\n    if (!exists) {\n      return callback();\n    }\n    rimraf(directory_path, callback);\n  });\n}\n\n/**\n * @param {String} file_path absolute path to file on disk\n * @return {Function} callback() if file does exist\n * callback(<error message>) if file does not exists\n */\nfunction confirm_file_exists(file_path, callback) {\n  fs.exists(file_path, function (exists) {\n    if (!exists) {\n      return callback('no file at path: ' + file_path);\n    }\n    return callback();\n  });\n};"}